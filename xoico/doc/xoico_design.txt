Author and Copyright 2020...2024 Johannes Bernhard Steffens

XOICO Framework Design

Xoila is a programming language that can be immersed with
c-code.

It was initially invented for the beth framework and originally called "beth_plant".
The term plant reflects the notion of 'planting' (embedding) dedicated code with regular
source code.

A xoila compiler translates xoila code into c-source code.
XOI code is located in C-header files.
Translated c-source code is written into dedicated files, which can be
included and compiled with other c-source code.

Copyright and License of generated code:
  Code generated by the xoila compiler inherits the copyright and license of the xoila
  source code. This information should have been placed inside the header file containing xoila
  source code. Generated files contain a list of source files used.

Usage:
XOILA_DEFINE_GROUP( <group_name>, <trait_name> )
#ifdef XOILA_SECTION
    signature <ret> <func_name>( {plain | const | mutable}, <args> );
           plain: plain function (no object pointer as first argument)
           const:   const member function;   first argument: const @* o
           mutable: mutable member function; first argument:       @* o

    signature extending <signature> <func_name>[( <additional-args> )];

    feature [strict] ['<flags>'] <syntax-of-signature> [ = <body> ];
    feature [strict] ['<flags>'] <syntax-of-signature> extern <name>;

    func feature : name [{ <body> }];

    stamp <name> [=] [aware] <trait> { reflection-body };
    stamp <name> [=] extending <tmpl> { reflection-body-extension }; // uses 'tmpl' as template to be extended; 'tmpl' can be a stamp or stump.
    stump ... // same as stamp definition. A 'stump' is not expanded into code. But it can be used as template. Stump-functions are overloadable.
    {stamp|stump} verbatim ....  // keyword 'verbatim' disables all automatic extensions for this definition

    // automatic extending
    extending <name>;    // stamp 'name' will be extended in all subsequent stamps that do not explicitly use 'extending'
    extending stump ...; // extends this stump definition
    extending;           // turns automatic extending off

    name       <name> [, <name>, <name>, ...];
    type       <name> [, <name>, <name>, ...];
    identifier <name> [, <name>, <name>, ...];
    forward    <expr> [, <expr>, <expr>, ...];

    group <name> = [<trait>] { ... }; // sub-group; inheriting from parent: 'extending'

    embed              "<embed file path>";
    include [deferred] "<include file path>"; // deferred inclusions are placed in the definition file

    ...
#endif // <xoila-closer>

xoila-opener:
  c-style comment-opener or '#ifdef XOILA_SECTION'
  Macro XOILA_SECTION must never be defined.

xoila-closer:
  c-style comment-closer or '#endif' (depending on what was used for xoila-opener)

----------------------------------------------------------------------------------------------
body:
  A body consists of C-code and specific xoila controls.

  body <name> [=] <body-expression>; // definition of a body

  <body-expression>:
     { code.... } [: <body-expression>];
     <body-name>  [: <body-expression>];

  inside body code:
     \body <body-expression>; // expands another body
     :<alphabetic-character>  // expands namespace
     :<space>                 // expands to ':<space>' (without evaluation)
     \:                       // expands to ':' (without evaluation)

----------------------------------------------------------------------------------------------
feature:
  The feature definition triggers implicit definition of a perspective <group_name>
  and corresponding inline implementations for each (virtual) function 'func_name'.
  <flags>-setting (s.below) determines which referencing method is offered for the feature.

     Calling a feature depending on referencing method.
     Note:
       Calling an unbound function can result in a segmentation fault.
       Use check below to probe for a valid binding.
     <ret> <group_name>_p_<func_name>( const <group_name>_s* p, <args> );
     <ret> <group_name>_t_<func_name>( tp_t __t, [const] <group_name>* o, <args> );
     <ret> <group_name>_a_<func_name>( [const] <group_name>* o, <args> );
     <ret> <group_name>_r_<func_name>( const sr_s* o, <args> );

     Checks whether binding exists for given object.
     Existing <default_func> qualifies as valid binding for all objects.
     bl_t <group_name>_p_defines_<func_name>( const <group_name>_s* p );
     bl_t <group_name>_t_defines_<func_name>( tp_t t );
     bl_t <group_name>_a_defines_<func_name>( const <group_name>* o );
     bl_t <group_name>_r_defines_<func_name>( const sr_s* o );

  flags:
      Any character sub-list of 'ptar' specifying which type of virtual function shall
      be inline implemented. If no list is specified, 'a' is assumed.

  strict:
      Any object referenced by the perspective must define the function.

  default_name:
      If the feature has an assigned body, the underlying c-function is <group_name>_<feature_name>__default.
      If the feature has an externally implemented body, it must be declared by appending 'extern <name>',
      which resolves to the c-function name <group_name>_<feature_name>_<name>.

----------------------------------------------------------------------------------------------
name:
  Identifier definition. Generates tp_t TYPEOF_<name>. Registers <name> in name manager.
  <name> has global scope. Multiple definitions of the same name at different places are allowed.

----------------------------------------------------------------------------------------------
type:
  Like 'name' with additional type-registration at compiler level.
  This is used to tell the compiler about external types and traits. e.g. st_s, bcore_source, ...

----------------------------------------------------------------------------------------------
identifier:
  External identifier registration.
  External identifiers are typically used for functions from external libraries. It circumvents xoico's
  argument and type checking or type conversion but simply translates the function call as it appears intended.
  It is up to the programmer to use the identifier correctly.

----------------------------------------------------------------------------------------------
forward:
  Forward declaration. Generates tp_t TYPEOF_<name> and BCORE_FORWARD_OBJECT( <name> );
  <name> has global scope. Multiple definitions of the same forwarding at different places are allowed.

----------------------------------------------------------------------------------------------
stamp:

  Reflection of object definition for objects (see flect.h for general syntax)
  Function definitions in reflections are matched and bound to features or signatures.
  C-Prototypes are generated and registered as featured function.

  Function Syntax:
   func <group_name> . <signature_name> [inline|export] [[{] <body> [}]];
         <signature_name> is a signature defined in group <group_name>
         Creates a function <stamp_name>_s_<signature_name>.

   func <group_name> . <feature_name> [inline|export] [[{] <body> [}]];
         <feature_name> is a feature defined in group <group_name>
         Creates a function <stamp_name>_s_<feature_name> and binds it to <group_name>_<feature_name>.

   func (<signature-def>) [inline|export] [[{] <body> [}]];
         Creates a function <stamp_name>_s_<signature_name>.

  Special conditions:
    ':' following stamp means that '<group_name>_' is prefixed to the following name
    ':' instead of trait means that '<group_name>' is declared as trait
    ':' (no func) preceding an identifier name means that '<group_name>_' is prefixed to the following name
    ':' (in func) if no perspective name precedes ':' then <group_name> is used as perspective
   'func ^ : <func_name>'  <trait_name> is used as perspective

  Special characters:
    Special characters are evaluated and replaced with specific text
    for signature types and body code. Signature and body definition
    can be outside the stamp. Replacement happens in all stamps to which
    they are assigned.

    '@' : is replaced by the stamp's type name if expansion happens in a stamp.
        Otherwise it is replaced by the groups type name.
          Example: In stamp 'foo_s'
             @ is replaced by "foo_s"

  Special traits:
    bcore_array: expands additional array-functions
      void set_space( o, size ) // preallocation
      void set_size(  o, size ) // preallocation + size specification
      void clear(     o,      ) // clears array (sets space to 0)
      void push_c(    o, v    ) // pushes element by copying it
      void push_d(    o, v    ) // pushes element by passing ownership  (whether element is copied depends on array-type)

Functions:
  Features and functions can have a body.
  The body is normally enclosed in '{ ... }' Braces can be omitted if the body contains only a single statement.
  Symbol ':' immediately followed by a name serves as namespace expander
  Keywords: 'inline', 'export' preceding the body forces inline or not-inline expansion.
  Registration: group functions (functions which are not member of a stamp) are registered in the function manager (macro REGISTER_FUNC)

Functor-style stamp declaration:
  A functor in this context is a stamp that is created to represent one specific function.
  Here, a simplified syntax can makes the code better readable

  Syntax:
  stamp <stamp_decl_syntax> ( initializer arguments ) func <func_decl_syntax> { <function body> }

  In this context (initializer arguments) specify the compact initializer function arguments from which the stamp members are derived.

  Examples:

    (1) stamp without data members and with anonymous function

    stamp functor1_s func o( @*o ) = o;

    -- is equivalent to --

    stamp functor1_s
    {
        func o( @*o ) = o;
    }

    -------------------------

    (2) stamp with simple data members and with anonymous function

    stamp functor2_s( f3_t a, f3_t b ) func f3_t( @*o, f3_t c )
    {
        = o.a + o.b + c;
    }

    -- is equivalent to --

    stamp functor2_s
    {
        $ f3_t a;
        $ f3_t b;
        func f3_t( @*o, f3_t c )
        {
            = o.a + o.b + c;
        }
    }

    -------------------------

    (3) (stamp with advanced data members)

    stamp functor3_s( m st_s* a, d st_s* b, d aware my_group* c, c aware my_group* d );

    -- is equivalent to --

    stamp functor3_s
    {
        $ hidden st_s * a;     // pointer assigned
        $ st_s => b;           // pointer assigned
        $ aware my_group => c; // pointer assigned
        $ aware my_group => d; // object cloned
    }

    -------------------------

----------------------------------------------------------------------------------------------

set:
  Keyword 'set' defines certain group-specific flags:
    enroll: This flag forces all stamps in the group to be fully enrolled.
            This requires extra memory and is normally not recommended.
            It is useful when objects are intended to be always reverse-traceable by trait.

----------------------------------------------------------------------------------------------

Config File:
The config file is typically named *_xoico.cfg is specified once for each target.
It contains the list of source files, the list of dependencies and the compiler configuration.

Example:

-------------------------
name = "byth";

srcs =
[
    "group byth_plot    = x_inst byth_plot.py" // default embedding: as_string
    "group byth_forward = x_inst byth_forward.x",
    "group byth_frame   = x_inst byth_frame.x",
    "group byth_obj     = x_inst byth_obj.x",
];

deps =
[
    "../bcore/bcore_xoico.cfg: readonly",
    "../bmath/bmath_xoico.cfg"
];

<xoico_builder_target_s/>( .name = name, .sources = srcs, .dependencies = deps )
-------------------------

Changes in any code leads to updating all affected targets, this may also change targets in dependencies.
Exception: If a dependency is followed by ': readonly' the respective target is not updated.

Source embedding methods:
Different types of sources are embedded by different methods:
C-header files (*.h): These are parsed for xoila-sections code and translated as specified.

X files (*.x)       : These are translated as xoila code. A group and trade can be optionally specified
                      otherwise the filename (without extension) is taken as group name with trade x_inst.
                      spaces and dots inside the file name are replaces with '_'.

Other files         : Same group handling as x-files except that the default group name incudes the file's extension.
                      The files content is embedded (copied) into the build. The embedding method is specified below.

Embedding of other files:
The default assumption is that the source file is a text file in UTF8 encoding.
It is translated into the builtin function 'd st_s* as_string();' returning the file's content as string.
Optionally, the embedding method is selectable using the 'embed' specifier after the file name:
Example:
    "group byth_plot = x_inst byth_plot.py: embed as_string"

----------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------

che syntax:

The cdaleth syntax is 'C' with additional syntactic rules.
Pure C-code can be enforced for any code block with this
syntax 'verbatim_C{ ... }'.

':' immediately before an identifier or '*' will replace ':' with the group name
'@' will be replaced with stamp instance name if applicable or with group name otherwise

typespec tracing:
The typespec is traced inside an expression whenever possible.

Where a typespec can be traced:
    '.' can be used as member access even when the variable is a pointer.
    Member functions can be called as element functions.

Casting:
    'cast( <typespec>, <expression> )'
translates to
   '( ( <typespec> )  ( <expression> ) )'
or
   '( ( <typespec> ) &( <expression> ) )'
in case <typespec>'s indirection is one above <expression>.

Arrays:
'<expr1>.[ <expr1> ]' translates to '<expr1>.data[ <expr1> ]'
If <expr1> represents a stamp with an anonymous array element.

Automatic variable definition:
 '<name> := <expression>' translates to <typespec> '<name> = <expression>'
 with <typespec> being the typespec of <expression>

Function pointer:
If an object-element is a function pointer, calling that function must be enclosed
in 'verbatim_C{ ... }'.

Setting indirection:
<expr>.<positive integer literal>
sets indirection-level.

Anonymous Function:
The anonymous function is allowed. It is a function where the name is an empty string.

Compact Function:
A compact function is a member function of a stamp and has the name '_'.
A compact function call is done without using the '.' delimiter: my_stamp( ... );

Compact Initializer:
Certain elements of a stamp can be marked using a preceding '$':
stamp my_stamp_s { $ f3_t a; $ st_s => b; $ st_s c; };
In that case a compact initializer funtion is automatically generated:
func (my_stamp_s) (o _(m@* o, f3_t a, d st_s* b, c st_s* c )) =
{
    o.a = a;
    o.b =< b;
    o.c.copy( c );
    return o;
}

Completion (Return statement) '=':
Using '=' as statement is interpreted as completion.
At this corresponds to using a return statement
Example:
func ( sz_t seven() ) { = 7; };


group signal callback function:
A group reserves two special (optional) functions which, if defined, are called by the init1, down1 signal handler.
These functions are called signal_init and signal_down. They may not be used for any other purpose and must
have the following signature:
func void group_signal_init1();
func void group_signal_down1();

group_signal_init1() is called last during the init1 signal cycle for the specifc group.
group_signal_down1() is called first during the down1 signal cycle for the specifc group.

These function can be used to initialize/discard global objects (e.g. constants) or
call initializaer/destructors of external libraries, plugins, etc.

===================================================================
FEATURES, BUGS ...

- (done) each group has a perspective
- (done) each group has default (aware, typed) features: *_t_create, _a_discard, _a_attach, _a_detach, _a_copy, _t_clone
- (done) add inexpandable features for above functions
- (done) rename default bodies of features from *__ to *_default.  (the default name can also be manually set)
- (done) new operator '=<' corresponds to function attach; expr =< NULL corresponds to detach;
- (done) attach on groups: check for type consistency
- (done) positfix operator '!' after a type converts it into a traced <type>_create(); (no effect if lvalue has indirection 0)
- (done) positfix operator '?.' after a type checks if lvalue is zero before dereferencing (no effect if lvalue has indirection 0)
- (done) provide foreach - loop
- (pending) bounds check '?[<index>]' checks if index is out of range
- (done) do not adapt indirection of void pointer types vc_t, vd_t
- (done) introduce verbatim_C{ .... } where code inside {} is taken as literal C code.
- (done) replace {\C .... } with {verbatim_C{ .... }}
- (done) add type specifier 'keep' (e.g. to be used in function returns) telling the compiler to take control of the object's lifetime
- (done) add lifetime management for return and break statements
- (done) isolate trans_declaration: processes declaration (with assignment) in case a declaration is intended, otherwise does nothing.
- (done) move trans_declaration from trans_expression to trans_statement and trans_for
- (done) try-block: auto-try statement when yielded value is er_t
- (done) add 'fork' a functional keyword representing a type-reserving bcore_fork.
- (done) add 'keep_func', 'keep_block'
- (deprecated) redefine keep: scope( expr [, var] ), which keeps the result of expression in the scope of var. Without 'var', the scope is the current block.
- (done) implement try-expression
- (done) allow signature definition along with function declaration
- (done) allow stamp member function declaration outside stamp
- (done) allow signature definition inside a function declaration
- (done) remove redundant 'plain' specifier in plain-functions
- (done) replace function name delimiter ':' with '.'
- (done) bracket-expressions '(....)' should yield typespec where possible
- (fixed) bug: too many closing ')' stalls
- (done) let variable declaration hide a type of same name

- (speculative) modify trans_declaration: flag indicating that the declaration in c-code is to be prepended
- (speculative) prepend flagged declarations to the beginning of the current block
- (speculative) allow (prepended) declaration after opening a bracket
- (speculative) auto-scpect function return values marked 'scpect'

- (speculative) non declarative assignment: allow full adaptation.
    Problems:
      - Use of prefix '*', '&' requires priority handling.
      - When the target indirection is changed the actual desired functionality might change drastically in an unpredictable manner.
             - not clear what is intended with the target's 'old' object.
             - id-level1: not clear if source is to be copied or merely referenced;
             - not clear if scoping is desired.
             --> when the target's indirection is changed, actual code must change at various places
                 adaptation of indirection might hide this necessity -> possible source of bugs.

- (done) define plain functions in a group
- (done) cengine: recognize a full function name (non-member)
- (fixed) bug: bodyless function can be added to a stamp after the same function was defined with a body (removing the body again)
- (fixed) bug: functions in groups do not affect its hash value
- (done) add includes to be placed in *xoila_out.{c,h} files
- (done) detect c-style arrays  (variables should have proper indirection)

- (fixed) bug: If the parser encounters a return or break statement, lifetime manager is not taken down in case the parser has not seen any 'scope' yet' .
  -> fix: remember such return or break positions and revisit them after a block has been completed. (fixed in 'che')

- (speculative - might introduce dependencies I'd like to avoid) apply automatic cast in adaptations in case of type discrepancy if target is in auto-cast list.
- (done) automatically cast of stamp to group is stamp is aware
- (done) detect an untractable function call: otherwise the bracket section might be traced and considered an expression with typespec
- (done) add functions with variadic arguments
- (fixed: bl_t was not registered as type) bug: bl_t modified = false; // modified seems not registered as variable
- (done) allow adaptation across indirection difference >1 if possible.
- (done) introduce postfix operators to set indirection
- (rejected) disallow prefix operator *, & for changing indirection  (causes too many problems with untraced c-code; main objective for this feature (adaptive assignment) was rejected)
- (done) use numeric value to specify indirection-level.
- (done) disallow 'continue'
- (done) disallow 'goto'
- (done) allow block-keywords like try, verbatim_C to be used declarative for a body

- (done) introduce typed signatures
- (done) allow member functions in groups
- (done) make functions in a trait-line transparent:
    - function can be called as stamp or group member without explicitly changing perspective
    - a stamp or group can overload the function.
- (done) stamp definition and reference: require always explicit '*_s' format for the stamp name
- (done) add 'unaware' type modifier. Indicates that a typespec can be used to reference unaware objects (e.g. primitive objects).
       The implementation of such a function must handle unaware objects correctly.

- (done) typespec: add transient_class
   - used in function arguments indicating that the function's return type can be safely casted into the input type of the transient-argument.
   - used as a generic typelock (the stamp associates a type with the transient_class )
- (done) move standard array functions to explicit implementations in the corresponding group
- (done) introduce function wrapping mechanism for a group function
- (done) decompose reflection items in a stamp; parse and analyze them individually; compute actual reflection only in expand phase
- (done) func: have xoico_func_s own signature;
- (done) func: finalize: resolve all transient type; relent to host obj_type
- (done: waive-flags) c-he: add purity level; higher purity raises errors on untraced conditions
- (done) fully handle default functions for arrays  (add them as 'func' and let cengine generate the code)
- (done) introduce simple way to call the default implementation of a feature
- (done) introduce simple way to test if a feature is implemented
- (yes) is term 'indirection' proper?
- (speculative) syntax: accessing a feature as non-function-member yields (non-addressable) bl_t indicating if function is defined for the object
    e.g.:  if( source.get_index ) --> if( bcore_source_a_defines_get_index( source ) )
- (fixed) bug: stamp default function 'create' is not registered
- (fixed) bug: a feature declared in a stump fails binding and does not produce an error if it is defined in a stamp as non-feature member function
- (done) introduce operators !^ and !^^ combining create and scoping (!^ is local scope, !^^ function scope)
- (done) non declarative assignment:
  if both sides of assignment are traceable:
    - allow type adaptation if target type is a group
    - error in case of indirection mismatch.
- (fixed) bug: c-style ternary operator does not capture the yielded types in all situations
- (done) allow implicit cast from pointer to bl_t
- (done) allow restrict keyword in declarations, casts, etc
- (done) signature: remove 'typed' keyword and typed mechanism (reason: not practical)
- (done) signature:
   - formulate all arguments (including the object argument) in the same way in a unique order
   - The object argument can only be the first argument of the list. It must also carry the name 'o'
   - In all other cases, the function has no object argument. <=> plain function
- (done) allow restrict keyword in main object of member signatures
- (done) check/handle 'discardable'
   (done) operator scope
   (done) operator <type>!
   (done) operator fork
   (done) operator =<
   (done) declaration with assignment
   (done) adaptations
   (done) returns
- (fixed) bug: function argument: resolving transient type: is target type is a group, no automatic conversion from stamp (cast required)
- (done) transient argument: signature return may optionally state an argument name instead of return-typespec. This makes the entire typespec of the corresponding argument transient.
- (done via transient argument) typespec: optionally tie access-class to a transient type
- (done) typespec: convert access-class flags to tp_t access-class
- (done) che_s: copy signature as state variable; remove typespec_ret, member_obj_type, etc
- (rejected (alternative via transient argument)) introduce transient 'const' in connection with a transient type: eg.: ((const)TO) x_inst* arg
- (done) disallow signature repetition for same function (use plain name solution below)
- (done) func declaration/definition: function name without preceding *. assumes that the signature-name is <host-name>_func_name.
- (done) generalize operators '^, ^^': if l-value is discardable, scope it.  (substitute of builtin function 'scope')
- (done) on stack declaration: scope instances on stack using ^ type specifier. example: st_s^ st;
- (done) on stack declaration: allow subsequent typespec expression in case a stack expression was properly scoped: example: st_s^ st.push_sc( "abc" );
- (done) include syntax: use include 'h' and include 'c' instead of include [deferred]
- (done) bug: transient argument: returned typespec is derived from the unadapted indirection (fix: take indirection from the adapted typespec)
- (done) add target flag: define_signal_handler: implements the signal handler in *_xo.c
- (done) foreach: extend syntax: foreach( <decl> in <arr>[..<sub_element_path>] [;<condition>] ) <statement>;
- (done) parsing an argument should not tolerate 'deduce'
- (fixed) bug: using '..' out of context causes an endless loop (observed in expression: x_via_path_s!^.parse_sc( "[0]" ).c_get_in( zoo )..to_sink_txt_ml( x_inst_stdout() ); )
- (done) rename keyword 'unaware' -> 'obliv'
- (done) stamp: require keyword 'obliv' for unaware stamps.
- (done) stamp: make keyword 'aware' optional. (aware is default)
- (done) typespec: make 'const' default; make declaring 'const' optional
- (done) Define signature main in x_inst.
     -   Defining a function with this signature generates the main function int main( int argc, char** argv ) of a program
     -   Dependencies are automatically initialized
- (done) where possible switch projects to define signal handler in *_xo.c
- (done) set target flag 'define_signal_handler' true by default.
- (done) x_inst: add transient functions for reflection access
- (done) config file: embed *.x files directly;
     syntax1: group <group_name> = <trait_name> <filename>.x
     syntax2: <filename>.x
     syntax2 assumes <group_name> = <filename> and <trait_name> = x_inst
- (fixed) bug: in-place expansion does not work for nested groups (nested groups are declared after expansion): fix: move in-place expansion to the end of *.xo.h
- (done) a 'type' or 'name'-identifier used with subsequent '~' translates into TYPEOF_<identifier>
- (done) get rid of BCORE_STDOUT, BCORE_STDERR (use global sinks instead)
- (done) group: allow spreading a group across multiple different group sections
         a name-clash is interpreted as continuation of the group
- (done) allow automatic dereferencing across more than one indirection levels
- (done) if a function was declared in a stamp, implementing it outside should always be possible simply by specifying the member name (without group)
- (done) stamp: default trait is group in which the stamp is defined
- (done) add registry for unspecific identifiers (allows disabling unknown identifier waiver)
- (fixed) bug: che: 1e-4 (and similar) is not recognized as numeric expression
- (done) che: add waiver for unknown type (in arglist or inside a function)
- (fixed by waivable error) bug:
    if( <cond> ) var = type!^;
    behaves like
    if( <cond> ) { var = type!^; }
    This leaves var as dangling pointer after if ...;
    Minimal solution: create an error requesting to use brackets in this case.
    Btw: if( <cond> ) var = type!^^; behaves correctly
- (done) group: retrievable: setup a global tp list of all stamps that have this group in their trait line
- (fixed) foreach: if expression uses life control, it is not correctly set up
- (fixed) bug: foreach: breaking into wrong break_ledge
- (fixed) bug: stamp: member function and object of same name causes unexpected problems: function calls not expanded properly
            situation: element name and function name of same name need to be allowed (many objects use it and it often makes sense semantically)
            cause: 'get_type_element_info' returns matching object even if a function call is intended.
            fix: in function trans_typespec_member: check first if a function call is intended "#?'('", then look up the
                 dedicated member entry for functions or objects. This needs a modification of function 'get_type_element_info'
- (done) x_via: rename to x_stamp
- (done) type modifier: treat type modifiers in variable and arg declarations equally
- (done) assignment: extend auto type conversion to leaf-types excluding pointer-types
- (rejected) trailine function: make only true member functions visible as traitline functions to a given object (no plain functions)
  Reason for rejection: Many traitline functions (e.g. x_* groups) should be seen as member functions even though they do not formally need an object input (sometimes just a type)
- (solved) Problem: scoping an oblivious instance: x_inst_t_create( tp_t )^
      scoping assumes instance is aware.
      Fix:
        let x_inst_t return 'obliv'; (same for other typed factories); check for obliv on scoping
        introduce t_scope builtin function, accepting type variable as argument
- (done) feature: typed function (switch first two arguments: type,object --> object,type )

- (done) group name declaration: disallow space between ':' and group-name

- (done) stamp: parsing reflection:
   - only pre-parse in parse-extend; move syntax evaluation happen to finalize
   - remove superfluous members self_buf an first_array_item
   - extended error checks

- (done) try: allow try blocks in functions not returning er_t.
        In such functions in case or error lifetime manager shuts down safely and bcore_down_exit( error_code ) is called.

- (done) enable function-wide (try) by default (can be disabled via che parameter)
- (done) transient arg: if transient type is a stamp check correct type of type of passed element
- (fixed) bug: xoico_builder_target_s (cfg file) changing waiver flags does not rebuild affected code in functions
- (done: not a bug) not returning a value when a return is expected does not clean up lifetime framework.
   not a bug: xoico does not trace all possible return paths in a function and therefore
   does not know if at its end a return would always be executed. Always formally Adding BLM_DOWN
   is a solution but is just redundant code for correct implementations. (c-compiler warns in case of missing return)

- (done) include: allow use of angle brackets <...>
- (done) cfg: specify output folder for (*.xo.*) files (if not specified current behavior is default)
- (done) xoico: override output folder for all dependencies via command line
- (done) group: 'type' and 'identifier' declarations need to affect pre_hash
- (done) auto cast sd_t -> sc_t is allowed
- (fixed) bug: endless loop if a syntax error yields a non-progressing statement
- (done) che (defaults): disable as many waivers as possible
- (done) introduce anonymous signatures (signature without name) - algorithmically treat the signature as if it had the name "" (empty string)
- (done) stamp member function
   - introduce a generic arglist that matches the element list of the stamp for specifically marked elements
   - introduce a function for compact syntax
          mystamp_s^ mystamp( 3, 7 );
          d$* something = mystamp_s!( 3, 7 );
- (fixed) bug: compact initializer: error in case compact type is not already registered

- (done) cast: introduce cast result

- (done) cast: remove unnecessary casts in the final code
    - final cast in a statement
    - successive casts that can be resolved to a single one

- (done) allow '=' as completion (return) statement
- (done) error in case function returning a value has no completion or no verbatim statement
- (done) function/body definition: assignment symbol is optional
- (done) stamp definition: assignment symbol is optional
- (done) group definition: assignment symbol is optional
- (done) feature with default function: assignment symbol is optional
- (done) transient types declaration in stamp: use 'trans' prefix to distinguish from mere functor-style arguments
- (done) function definition: turn requirement of extra brackets (...) for signature definition to optional:
         try signature definition first, if pattern mismatches assume signature name
- (done) stamp declaration: allow omitting braces in case of no or just one element
- (done) stamp declaration: (functor style) allow compact initializing object declared via argument list

- (done) make semicolons after stamp, func, group optional

- (done)
  Transient types: automatically overload feature in traitline with same name as transient type identifier
  This allows generic function to retrieve the actual type at runtime.
  First used in: x_hmap

- (done) stamp: parsing reflection:
   - automatic assume 'aware' for group types when type-awareness is not explicitly specified (e.g. by aware/typed/obliv)

- (done) Autocompletion:
   - func body: when return object is declared to be one of the arguments but function body does not explicitly return anything,
     append return <arg> as final statement

- (done) remove function body prefixes: disallow prefixes (try), (verbatim_C)
- (done) disallow explicit function body assignemnt

- (done) single-statement-function: if a function's body' contains only a single statement, it can be defined without braces { ... }
- (done) single-statement-function: test blm behavior extensively
- (fixed) bug: automatic cast of function return on a function call is invoked far too often because only typespec hash values are compared
- (fixed) Bug Autocompletion: Autocompletion does not work on a feature's default body
- (done) Introduce c-style main function x_inst.main_c
- (fixed) Bug: whitespaces in transient list declaration not consumed

- (done) group: add optional list of transient types (same syntax as for stamps);
                stamps and groups defined in this group inherit this list;
                stamps, groups defining own transient types update their predefined list.

- (fixed) bug: a feature's signature defined with transient types does not retain transient properties on group level
- (fixed) bug: crash in case group's' trait name is not a group
- (done) allow calling a global function as member function of an object: obj.<global_func_name>( .... )
- (done) Keywords: 'inline', 'export' preceding the body forces inline or not-inline expansion

- (speculative) introduce a functor:
  syntax on group level.
  Example:
  functor sz_t fu_s( sz_t a, sz_t b ).( sz_t c ) { = a + b + c; };
  Resolves to
  stamp :fu_s { $ sz_t a; $ sz_t_b; func sz_t ( sz_t c ) { = o.a + o.b + c; }; };
  Issues:
  - Alternative exists: functor-style stamp declaration availabe
        stamp fu_s( sz_t a, sz_t b ) func sz_t ( sz_t c ) = o.a + o.b + c;
  - The term 'functor' carries a different meaning in mathematics.

- (done) Add member shrotcuts:
    .! expands to .clone()
    .# expands to .fork()

- (done) Bug fix: overload feature transient type definition as if it occurs in traitline

TODO:

- stamp: allow function-style readonly request of a member variable even if the function was not defined

- introduce builtin ternary operator 'iff' as builtin function (might be solved by a transient function in x_inst)
- make traitline of all groups end in x_inst
- make 'fork' a transient function in x_inst rather than a builtin function

- cast: introduce aware_cast( <typespec> ) as cast-variation on object indirection > 0 with runtime type-check
     - assumes that all objects involved are aware
     - NULL results in NULL
     - if <typespec> is a stamp, the object's type is checked at runtime and NULL returned in case of mismatch

- Allow indirection-0-assignment after scoped on-stack declaration.
  But: do not allow automatic indirection adjustment for this case.
   Motivation:
     - Simplifies handling of of sr_s
     - Potential for unintended destructive cases is low as long as automatic indirection adjustment is prevented.

- target.cfg file: source: listing a *.x file without group specification automatically adds it to a common group
  of name 'target-name' instead of creating a dedicated group.

===================================================================

Keywords (for syntax highlight)

group stamp stump hidden private func name signature body obliv aware feature extending verbatim
mutable discardable retrievable forward include embed cast foreach in verbatim_C fork
strict try scope t_scope scope_local scope_func extern wrap restrict type identifier trans TE TO

Leaf types (for syntax highlight)

s3_t s2_t s1_t s0_t u3_t u2_t u1_t u0_t f3_t f2_t sz_t uz_t bl_t tp_t er_t aware_t offset_t
smax_t umax_t sd_t sc_t vd_t vc_t nd_t fp_t atomic_tp_t atomic_vc_t atomic_fp_t



