# Application make framework
# Author: Johannes B. Steffens
#
# Application Structure:
# Applications have a root folder that determines the name of the application
# The apps makefile is located at that root folder.
#
# A xoico config file is optional but if the app has one,
# it must be stored as <root>/<apppname>_xoico.cfg.
# Dependencies of this file may have different names but should end in *.cfg.
#
# Code (*.c, *.h, *.x, *.cfg) is located per library in folder
# <root>/src
#
# Binary code (*.o, <appname> - executable) generated by makefiles is stored in
# <root>/bin/...
#
# Dependencies are specified as list by variable DEPENDENCIES
# Each dependency must be a library.
# Each dependency is specified as path to the library.
# e.g. ../../beth/lib/bcore
#
# The root folder and application name are automatically determined by the location of the makefile.
#
# Usage:
# In the apps root folder, create a makefile as follows ((O) means Optional):
#
# BETH_DIR     = <beth root folder>
# DEPENDENCIES = <dependencies>   example: DEPENDENCIES =  $(BETH_DIR)/lib/bmath $(BETH_DIR)/lib/bcore ...
# (O) DO_NOT_CLEAN_XO_FILES = 1 # This prevents *.xo.{h,c} from being deleted in clean operation
# (O) POSTBUILD = ... # List of postbuild commands separated by ';'
# (O) CLEAN     = ... # List of extra cleanup commands separated by ';'
# (O) CFLAGS    = ... # List of extra compiler flags before default flags
# (O) LIBS      = ... # List of extra libraries before default libraries
# (O) LDFLAGS   = ... # List of extra linker flags before default flags
# (O) RUN_ARGS  = ... # App default arguments for execution (see rule 'run')
#
# include $(BETH_DIR)/mk/app.mk
#
# (O) CFLAGS   += ... # List of extra compiler flags after default flags
# (O) LIBS     += ... # List of extra libraries after default libraries
# (O) LDFLAGS  += ... # List of extra linker flags after default flags

NAME      = $(notdir $(CURDIR))
ROOT_DIR  = $(CURDIR)
BIN_DIR   = $(ROOT_DIR)/bin
OBJ_DIR   = $(BIN_DIR)/obj
SRC_DIR   = $(ROOT_DIR)/src
TARGET    = $(BIN_DIR)/$(NAME)
XOICO_CFG = $(wildcard $(NAME)_xoico.cfg)
INCLUDES  = $(foreach dep,$(DEPENDENCIES),-I $(dep))

# sort removes duplicates
A_DIRS    = $(sort $(foreach dep,$(DEPENDENCIES), $(dir $(patsubst %/,%,$(dir $(dep))))bin))

LIBS     += $(foreach dep,$(DEPENDENCIES),$(notdir $(dep)))
LIBS     += m pthread atomic

LDFLAGS  += -fopenmp
LDFLAGS  += $(foreach val,$(A_DIRS),-L $(val))
LDFLAGS  += $(addprefix -l, $(LIBS))

ifneq ($(XOICO_CFG),)
XO_STATE = $(NAME).xo.state
endif

XOICO_DIR    = $(BETH_DIR)/xoico
CC           = gcc
AR           = ar
MAKE         = make
XOICO        = $(XOICO_DIR)/bin/xoico
CFLAGS      += -Wall -fopenmp -O3 -std=c11

C_FILES = $(wildcard $(SRC_DIR)/*.c)
O_FILES = $(C_FILES:$(SRC_DIR)/%.c=$(OBJ_DIR)/%.o)

ALL_SRC_FOLDERS = $(SRC_DIR) $(DEPENDENCIES)

ALL_H_FILES = $(foreach folder,$(ALL_SRC_FOLDERS),$(wildcard $(folder)/*.h))
ALL_C_FILES = $(foreach folder,$(ALL_SRC_FOLDERS),$(wildcard $(folder)/*.c))
ALL_X_FILES = $(foreach folder,$(ALL_SRC_FOLDERS),$(wildcard $(folder)/*.x))
ALL_G_FILES = $(foreach folder,$(ALL_SRC_FOLDERS),$(wildcard $(folder)/*.cfg))

.PHONY: run clean cleanall pass2 rebuild rebuildall

$(TARGET): $(XOICO) $(XO_STATE) $(ALL_C_FILES) $(ALL_H_FILES) $(ALL_X_FILES) $(ALL_G_FILES)
	$(foreach dep,$(DEPENDENCIES),$(MAKE) -C $(dep);)
	# second pass to capture changes by xoico
	$(MAKE) -j12 -C . pass2
	$(POSTBUILD)

pass2: $(O_FILES)
	@mkdir -p $(dir $(TARGET) )
	$(CC) -o $(TARGET) $(CFLAGS) $(INCLUDES) $(O_FILES) $(LDFLAGS)

$(XO_STATE): $(XOICO) $(ALL_H_FILES) $(ALL_X_FILES) $(ALL_G_FILES)
	$(XOICO) $(XOICO_CFG)
	touch $(XO_STATE)

$(BIN_DIR)/lib%.a: $(ROOT_DIR)/lib/%/.
	$(MAKE) -C $<

$(OBJ_DIR)/%.o: $(SRC_DIR)/%.c $(ALL_H_FILES)
	@mkdir -p $(dir $(@) )
	$(CC) $(CFLAGS) $(INCLUDES) -c $< -o $@

$(XOICO):
	$(MAKE) -C $(XOICO_DIR)

run:
	$(MAKE)
	$(TARGET) $(RUN_ARGS)

clean:
	rm -f  $(TARGET)
	rm -rf $(OBJ_DIR)
ifndef DO_NOT_CLEAN_XO_FILES
	rm -f $(XO_STATE)
	rm -f $(SRC_DIR)/*.xo.h
	rm -f $(SRC_DIR)/*.xo.c
	rm -f $(SRC_DIR)/*.xo.state
endif
	$(CLEAN)

cleanall:
	$(MAKE) clean
	$(foreach dep,$(DEPENDENCIES),$(MAKE) -C $(dep) clean;)

rebuild:
	$(MAKE) clean
	$(MAKE)

rebuildall:
	$(MAKE) cleanall
	$(MAKE)

