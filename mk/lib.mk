# Library make framework
# Author: Johannes B. Steffens
#
# Library Structure:
# Libraries have a root folder of arbitrary name <root>
#
# Code (*.c, *.h, *.x, *.cfg, makefile) is located per library in folder
# <root>/lib/<libname>
# Each library has a makefile in the code folder
#
# Binary code (*.a,*.o) generated by makefiles is stored in
# <root>/bin/...
#
# Dependencies are specified as list by variable DEPENDENCIES
# Each dependency must be a library.
# Each dependency is specified as path to the library.
# e.g. ../../beth/lib/bcore
#
# A xoico config file is optional but if the library has one, 
# it must be stored as <root>/lib/<libname>/<libname>_xoico.cfg.
# Dependencies of this file may have different names but should end in *.cfg.
#
# Library files will be stored as <root>/bin/lib<libname>.a
#
# The root folder and library name are automatically determined by the location of the makefile.
#
# Usage: 
# In folder with source files, create a makefile as follows ((O) means optional):
#
# BETH_DIR  = <beth root folder>
# DEPENDENCIES = <dependencies>   e.g.: ../bmath ../bcore ...
# (O) DO_NOT_CLEAN_XO_FILES = 1 # This prevents *.xo.{h,c} from being deleted in clean operation
# (O) CFLAGS    = ... # List of extra compiler flags before default flags
# (O) AFLAGS    = ... # List of extra archiver flags before default flags
#
# include $(BETH_DIR)/mk/lib.mk
#
# (O) CFLAGS   += ... # List of extra compiler flags after default flags
# (O) AFLAGS   += ... # List of extra archiver flags after default flags

NAME      = $(notdir $(CURDIR))

ROOT_DIR  = $(patsubst %/,%,$(dir $(patsubst %/,%,$(dir $(CURDIR)))))
BIN_DIR   = $(ROOT_DIR)/bin
OBJ_DIR   = $(BIN_DIR)/obj/$(NAME)
TARGET    = $(BIN_DIR)/lib$(NAME).a
XOICO_CFG = $(wildcard $(NAME)_xoico.cfg)
INCLUDES  = $(foreach dep,$(DEPENDENCIES),-I $(dep))
ifneq ($(XOICO_CFG),)
XO_STATE = $(NAME).xo.state
endif

XOICO_DIR    = $(BETH_DIR)/xoico
CC           = gcc
AR           = ar
MAKE         = make
XOICO        = $(XOICO_DIR)/bin/xoico
CFLAGS      += -Wall -O3 -fopenmp -std=c11 
AFLAGS      += -r -s

C_FILES = $(wildcard *.c)
O_FILES = $(C_FILES:%.c=$(OBJ_DIR)/%.o)

ALL_SRC_FOLDERS = $(CURDIR) $(DEPENDENCIES)

ALL_H_FILES = $(foreach folder,$(ALL_SRC_FOLDERS),$(wildcard $(folder)/*.h))
ALL_C_FILES = $(foreach folder,$(ALL_SRC_FOLDERS),$(wildcard $(folder)/*.c))
ALL_X_FILES = $(foreach folder,$(ALL_SRC_FOLDERS),$(wildcard $(folder)/*.x))
ALL_G_FILES = $(foreach folder,$(ALL_SRC_FOLDERS),$(wildcard $(folder)/*.cfg))

.PHONY: clean cleanall pass2 rebuild rebuildall

$(TARGET): $(XOICO) $(XO_STATE) $(ALL_C_FILES) $(ALL_H_FILES) $(ALL_X_FILES) $(ALL_G_FILES)
	$(foreach dep,$(DEPENDENCIES),$(MAKE) -C $(dep);)
        # second pass to capture changes by xoico
	$(MAKE) -j12 -C . pass2
	
pass2: $(O_FILES)
	@mkdir -p $(dir $(TARGET) )
	$(AR) $(AFLAGS) $(TARGET) $(O_FILES)

$(XO_STATE): $(XOICO) $(ALL_H_FILES) $(ALL_X_FILES) $(ALL_G_FILES)
	$(XOICO) $(XOICO_CFG)
	touch $(XO_STATE)

$(BIN_DIR)/lib%.a: $(ROOT_DIR)/lib/%/.
	$(MAKE) -C $<

$(OBJ_DIR)/%.o: %.c $(ALL_H_FILES)
	@mkdir -p $(dir $(@) )
	$(CC) $(CFLAGS) $(INCLUDES) -c $< -o $@

$(XOICO):
	$(MAKE) -C $(XOICO_DIR)	

clean:
	rm -f  $(TARGET)
	rm -rf $(OBJ_DIR)
ifndef DO_NOT_CLEAN_XO_FILES
	rm -f *.xo.h
	rm -f *.xo.c
	rm -f *.xo.state
endif

cleanall:
	$(MAKE) clean
	$(foreach dep,$(DEPENDENCIES),$(MAKE) -C $(dep) clean;)

rebuild:
	$(MAKE) clean
	$(MAKE)

rebuildall:
	$(MAKE) cleanall
	$(MAKE)

