/** BTCL selftest
 *  Returns number of failed tests.
 */

(

embed( "../selftest/embed.btcl" );

err = 0;

err = err + !test( "constant", TRUE == (1==1) );

err = err + !test( "arithmetic", 5 + 3 * 2 == 11 );
err = err + !test( "arithmetic", 5^2 == 25 );
err = err + !test( "arithmetic", 13%10 == 3 );
err = err + !test( "negation", -( 5 + 3 * 2 ) == 0-11 );
err = err + !test( "variable", x = 5; x + 3 * 2 == 11 );
err = err + !test( "string1", x = 12; x + "ab" + x == "12ab12" );
err = err + !test( "string2", x = 12; x + x + "ab" == "24ab" );
err = err + !test( "prefix priority", x = func(){5}; -x()*2 == -10 );

// ---------------------------------------------------------------------------------------------------------------------
/// recursions

// infinite recursions: expression below should produce a frame depth error
// func() { self() }();

/// factorial function
factorial = func( x ) { if( x <= 1 ) { 1.0 } else { x * self( x - 1 ) } };

err = err + !test( "factorial", factorial( 4 ) == 24 );

/// ackermann function
ackermann = func( n, m )
{
    if( n == 0 )
    {
        m + 1
    }
    else
    {
        if( m == 0 )
        {
            self( n - 1, 1 )
        }
        else
        {
            self( n - 1, self( n, m - 1 ) )
        }
    }
};

err = err + !test( "ackermann", ackermann( 3, 1 ) == 13 );

// ---------------------------------------------------------------------------------------------------------------------
/// stamps, members, type conversion

s = <bmath_mfx_eval_s> rows: 10 cols: 20 </>;
err = err + !test( "member query 1", s.rows == 10 & s.cols == 20 );

// modifier
s = s( .rows = 30, .cols = 40 );
err = err + !test( "member query 2", s.rows == 30 & s.cols == 40 );

// type conversion float -> bool
err = err + !test( "member query 2", <bl_t/>( 0.5 ) == TRUE );


// ---------------------------------------------------------------------------------------------------------------------
/// lists

err = err + !test( "list init", [1,2,3] == 1:2:3 );
err = err + !test( "list init", [1,2,3] == [1,2]:3 );
err = err + !test( "list init", [1,2]:[3] == [1,2,3] );
err = err + !test( "list init", [1,2]:[[3]] == [1,2,[3]] );

list = [1,2,3];
err = err + !test( "list size", SIZE( list ) == 3 );
err = err + !test( "list size", list.SIZE() == 3 );
err = err + !test( "list size", list.arr.SIZE() == 3 );
err = err + !test( "list element", list.[ 0 ] == 1 & list.[ 1 ] == 2 );

arr = <bcore_arr_s3_s/>(list);
err = err + !test( "arr element", arr.[ 0 ] == 1 & arr.[ 1 ] == 2 );

err = err + !test( "list spawn", 3::0 == [0,0,0] );
err = err + !test( "list spawn", 3::func(x){x+1} == [1,2,3] );
err = err + !test( "list spawn", [1,2,3]::func(x){-x} == [-1,-2,-3] );
err = err + !test( "list spawn", ([0]::[1,2]::[4,5]) == ([[0,1,4],[0,1,5],[0,2,4],[0,2,5]]) );

// ---------------------------------------------------------------------------------------------------------------------
/// spawned recursion

err = err + !test( "spawned recursion", ["a","b","c","d"] :: func(a,b) { a + b } == "abcd" );

// ---------------------------------------------------------------------------------------------------------------------
/// bug fixes

f = func(){y=10}; // assignment result was not cloned when frame was closed (bug returned 0)
err = err + !test( "bug: assignment lifetime", f() == 10 );

? if( err > 0 ) { "BTCL: Selftest failed.\n" } else { "BTCL: Selftest finished successfully.\n" };

err

)
